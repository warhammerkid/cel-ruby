class Cel::Parser

  prechigh
    nonassoc UMINUS
    left '*' '/'
    left '+' '-'
  preclow
rule
  target: exp
        | /* none */ { result = 0 }
  
  exp: exp '+' exp { result += val[2] }
     | exp '-' exp { result -= val[2] }
     | exp '*' exp { result *= val[2] }
     | exp '/' exp { result /= val[2] }
     | '(' exp ')' { result = val[1] }
     | '-' NUMBER  =UMINUS { result = -val[1] }
     | NUMBER
end
---- header
require 'strscan'
---- inner

RESERVED = %W[
 in
as break const continue else
for function if import let
loop package namespace return
var void while
]

RESERVED_REGEX = Regexp.union(*RESERVED)

STRING_LIT_REGEX = Regexp.union(
  /"""(?~""")*"""/,
  /'''(?~''')*'''/,
  /"(\"|[^"])*"/,
  /'(\'|[^'])*'/,
)

def parse(str)
  str.force_encoding(Encoding::BINARY) unless str.valid_encoding?

  scanner = StringScanner.new(str)

  @q = []

  until scanner.eos?
    case
    when scanner.scan(/\s+/)
      # skip whitespace
    when scanner.scan(/#(( *)|( ?(?<string>.*)))\n/)
      # skip comment lines
    when scanner.scan(/\-?((0x[0-9a-fA-F]+[uU]?)|\d+[uU])/) # uint/int integer
      @q << [:tNUMBER, scanner.matched]
    when scanner.scan(/\-?(\d+|(\d*(\.\d+)))([eE][+\-]?\d+)?/) # float, integer
      @q << [:tNUMBER, scanner.matched]
    when scanner.scan(/true|false/)
      @q << [:tBOOL, scanner.matched]
    when scanner.scan(/null/)
      @q << [:tNULL]
    when scanner.scan(/[bB]?[rR]?#{STRING_LIT_REGEX}/) # string
      # s = scanner.matched.yield_self {|s| s[1, s.length - 2] }
      #                  .gsub(DBL_QUOTE_STR_ESCAPE_SEQUENCES_RE) do |match|
      #                    case match
      #                    when '\\a' then "\a"
      #                    when '\\b' then "\b"
      #                    when '\\e' then "\e"
      #                    when '\\f' then "\f"
      #                    when '\\n' then "\n"
      #                    when '\\r' then "\r"
      #                    when '\\s' then "\s"
      #                    when '\\t' then "\t"
      #                    when '\\v' then "\v"
      #                    when '\\"' then '"'
      #                    end
      #                  end
      
      # s = scanner.matched.yield_self {|s| s[1, s.length - 2] }.gsub(/\\'/, "'")

      @q << [:tSTRING, scanner.matched]
    when scanner.scan(RESERVED_REGEX)
      @q << [:tRESERVED, scanner.matched]
    when scanner.scan(/[a-zA-Z][_a-zA-Z0-9]*/)
      @q << [:tIDENTIFIER, scanner.matched]
    when scanner.scan(/\A.|\n/o)
      s = scanner.matched
      @q << [s, s]
    else
      puts "fuckness"
    end
  end
  @q << [false, '$end']
  puts @q.inspect
  # do_parse
end

def next_token
  @q.shift
end

def convert_to_number(str)
end

def convert_to_string(str)
end

---- footer

if $0 == __FILE__
  examples = <<EOS
123
12345
1.2
1e2
-1.2e2
12u
0xa123
""
'""'
'''x''x'''
"\""
"\\"
r"\\"
b"abc"
b"Ã¿"
b"\303\277"
"\303\277"
"\377"
b"\377"
"\xFF"
b"\xFF"

1 + 2
3 - 2
" Some String with \"escapes\""
'another string'
a.b.c == 1
d > 2
a.b.c * 3 == 1 && d > 2
a.b.c
wiri
// a.driving_license = "CA"
// 1 = 2
// 2 = "a"
// a.b.c > "a"
EOS
  puts 'Parsing...'
  parser = Cel::Parser.new
  examples.each_line do |line|
    puts "line: #{line.inspect}"
    puts parser.parse(line)
  end
end

# Expr           = ConditionalOr ["?" ConditionalOr ":" Expr] ;
# ConditionalOr  = [ConditionalOr "||"] ConditionalAnd ;
# ConditionalAnd = [ConditionalAnd "&&"] Relation ;
# Relation       = [Relation Relop] Addition ;
# Relop          = "<" | "<=" | ">=" | ">" | "==" | "!=" | "in" ;
# Addition       = [Addition ("+" | "-")] Multiplication ;
# Multiplication = [Multiplication ("*" | "/" | "%")] Unary ;
# Unary          = Member
#                | "!" {"!"} Member
#                | "-" {"-"} Member
#                ;
# Member         = Primary
#                | Member "." IDENT ["(" [ExprList] ")"]
#                | Member "[" Expr "]"
#                | Member "{" [FieldInits] "}"
#                ;
# Primary        = ["."] IDENT ["(" [ExprList] ")"]
#                | "(" Expr ")"
#                | "[" [ExprList] "]"
#                | "{" [MapInits] "}"
#                | LITERAL
#                ;
# ExprList       = Expr {"," Expr} ;
# FieldInits     = IDENT ":" Expr {"," IDENT ":" Expr} ;
# MapInits       = Expr ":" Expr {"," Expr ":" Expr} ;

# IDENT          ::= [_a-zA-Z][_a-zA-Z0-9]* - RESERVED
# LITERAL        ::= INT_LIT | UINT_LIT | FLOAT_LIT | STRING_LIT | BYTES_LIT
# | BOOL_LIT | NULL_LIT
# INT_LIT        ::= -? DIGIT+ | -? 0x HEXDIGIT+
# UINT_LIT       ::= INT_LIT [uU]
# FLOAT_LIT      ::= -? DIGIT* . DIGIT+ EXPONENT? | -? DIGIT+ EXPONENT
# DIGIT          ::= [0-9]
# HEXDIGIT       ::= [0-9abcdefABCDEF]
# EXPONENT       ::= [eE] [+-]? DIGIT+
# STRING_LIT     ::= [rR]? ( "    ~( " | NEWLINE )*  "
#         | '    ~( ' | NEWLINE )*  '
#         | """  ~"""*              """
#         | '''  ~'''*              '''
#         )
# BYTES_LIT      ::= [bB] STRING_LIT
# ESCAPE         ::= \ [bfnrt"'\]
# | \ x HEXDIGIT HEXDIGIT
# | \ u HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
# | \ U HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
# | \ [0-3] [0-7] [0-7]
# NEWLINE        ::= \r\n | \r | \n
# BOOL_LIT       ::= "true" | "false"
# NULL_LIT       ::= "null"
# RESERVED       ::= BOOL_LIT | NULL_LIT | "in"
# | "as" | "break" | "const" | "continue" | "else"
# | "for" | "function" | "if" | "import" | "let"
# | "loop" | "package" | "namespace" | "return"
# | "var" | "void" | "while"
# WHITESPACE     ::= [\t\n\f\r ]+
# COMMENT        ::= '//' ~NEWLINE* NEWLINE
