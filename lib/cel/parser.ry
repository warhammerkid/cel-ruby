class Cel::Parser
  token tINT tUINT tDOUBLE tBOOL tNULL tSTRING tBYTES tRESERVED tIDENTIFIER
        tMULTIOP tADDOP tSUBOP tRELOP tANDOP tOROP tEOF
  prechigh
    nonassoc UMINUS
    left tMULTIOP
    left tADDOP tSUBOP
    left tRELOP
    left tANDOP
    left tOROP
  preclow
rule
  target: expr eof
        | eof
  eof: tEOF


  expr: conditional_or "?" conditional_or ":" expr { result = Cel::Condition.new(val[0], val[2], val[4]) }
      | conditional_or

  conditional_or: conditional_or tOROP conditional_and { result = Cel::Operation.new(val[1], [val[0], val[2]]) }
                | conditional_and

  conditional_and: conditional_and tANDOP relation { result = Cel::Operation.new(val[1], [val[0], val[2]]) }
                 | relation

  relation: relation tRELOP addition { result = Cel::Operation.new(val[1], [val[0], val[2]]) }
          | addition

  addition: addition tADDOP multiplication { result = Cel::Operation.new(val[1], [val[0], val[2]]) }
          | addition tSUBOP multiplication { result = Cel::Operation.new(val[1], [val[0], val[2]]) }
          | multiplication

  multiplication: multiplication tMULTIOP unary { result = Cel::Operation.new(val[1], [val[0], val[2]]) }
                | unary


  unary: member
       | "!" negated_member { result = Cel::Operation.new("!", [val[1]]) }
       | tSUBOP negative_member { result = Cel::Operation.new("-", [val[1]]) }

  negated_member: "!" negated_member { result = Cel::Operation.new("!", [val[1]]) }
                | member

  negative_member: tSUBOP negative_member { result = Cel::Operation.new("-", [val[1]]) }
                | member

  member: primary
        | member "." tIDENTIFIER { result = Cel::Invoke.new(var: val[0], func: val[2]) }
        | member "." tIDENTIFIER '(' maybe_expr_list ')' { result = Cel::Invoke.new(var: val[0], func: val[2], args: [val[4]].flatten(1)) }
        | member '[' expr ']' { result = Cel::Invoke.new(var: val[0], func: "[]", args: val[2]) }
        | member '{' maybe_field_inits '}' { result = Cel::Message.new(val[0], val[2]) }


  primary:  identifier { result = Cel::Identifier.new(val[0]) }
         |  identifier '(' maybe_expr_list ')' { result = Cel::Invoke.new(func: val[0], args: [val[2]].flatten(1)) }
         | '(' expr ')' { result = Cel::Group.new(val[1]) }
         | '[' maybe_expr_list ']' { result = Cel::List.new(Array(val[1])) }
         | '{' maybe_map_inits '}' { result = Cel::Map.new(Hash[val[1]]) }
         | literal

  identifier: tIDENTIFIER
            | '.' tIDENTIFIER

  maybe_expr_list: expr_list
                 | { result = [] }

  maybe_map_inits: { result = {} }
                 | map_inits

  expr_list: expr_list ',' expr { result = Array(val[0]) << val[2] }
           | expr { [val[0]] }

  maybe_field_inits: { result = nil }
                   | field_inits

  field_inits: field_inits ',' tIDENTIFIER ":" expr { result = val[0].merge(Cel::Identifier.new(val[2]) => val[4]) }
             | tIDENTIFIER ":" expr { result = { Cel::Identifier.new(val[0]) => val[2] } }

  map_inits: map_inits ',' expr ':' expr { val[0][val[2]] = val[4]; result = val[0] }
           | expr ':' expr { result = { val[0] => val[2] } }

  literal: tINT { result = Cel::Number.new(:int, val[0]) }
         | tUINT { result = Cel::Number.new(:uint, val[0]) }
         | tDOUBLE { result = Cel::Number.new(:double, val[0]) }
         | tBOOL { result = Cel::Bool.new(val[0]) }
         | tNULL { result = Cel::Null.new() }
         | tSTRING { result = Cel::String.new(val[0]) }
         | tBYTES { result = Cel::Bytes.new(val[0]) }

end
---- header
require 'strscan'
require 'bigdecimal'
require 'cel/ast/elements'
---- inner



OPERATORS = if RUBY_VERSION < "2.7.0"
  {
    "&&" => :tANDOP,
    "||" => :tOROP,
    "+" => :tADDOP,
    "-" => :tSUBOP,
  }.merge(Hash[Cel::LOGICAL_OPERATORS.map{|op| [op, :tRELOP] }])
   .merge(Hash[Cel::MULTI_OPERATORS.map{|op| [op, :tMULTIOP] }])
else
  {
    **Hash[Cel::LOGICAL_OPERATORS.map{|op| [op, :tRELOP] }],
    **Hash[Cel::MULTI_OPERATORS.map{|op| [op, :tMULTIOP] }],
    "&&" => :tANDOP,
    "||" => :tOROP,
    "+" => :tADDOP,
    "-" => :tSUBOP,
  }
end.freeze

OPERATORS_RE = Regexp.union(*OPERATORS.keys)

BACKSLASH = "\\\\" # Must be literally two backslashes for proper interpolation
DIGIT     = "[0-9]"
EXPONENT  = "(?:[eE][+-]?#{DIGIT}+)"
HEXDIGIT  = "[0-9a-fA-F]"
RAW       = "(?<raw>[rR])"

ESC_CHAR_SEQ = "#{BACKSLASH}[abfnrtv\"'#{BACKSLASH}?`]"
ESC_OCT_SEQ  = "#{BACKSLASH}[0-3][0-7]{2}"
ESC_BYTE_SEQ = "#{BACKSLASH}[xX]#{HEXDIGIT}{2}"
ESC_UNI_SEQ  = "#{BACKSLASH}u#{HEXDIGIT}{4}|#{BACKSLASH}U#{HEXDIGIT}{8}"
ESC_SEQ      = "#{ESC_CHAR_SEQ}|#{ESC_BYTE_SEQ}|#{ESC_UNI_SEQ}|#{ESC_OCT_SEQ}"

WHITESPACE_REGEX = /[ \t\r\n\u000C]+/
COMMENT_REGEX = %r{//[^\n]*}

NUM_FLOAT_REGEX = Regexp.union(
  /#{DIGIT}+\.#{DIGIT}+#{EXPONENT}?/,
  /#{DIGIT}+#{EXPONENT}/,
  /\.#{DIGIT}+#{EXPONENT}?/
)

NUM_INT_REGEX = Regexp.union(
  /0x(?<hex>#{HEXDIGIT}+)/,
  /(?<dec>#{DIGIT}+)/
)

NUM_UINT_REGEX = Regexp.union(
  /0x(?<hex>#{HEXDIGIT}+)[uU]/,
  /(?<dec>#{DIGIT}+)[uU]/
)

STRING_REGEX = Regexp.union(
  /"""(?<str>(?:#{ESC_SEQ}|[^\\])*)"""/,
  /'''(?<str>(?:#{ESC_SEQ}|[^\\])*)'''/,
  /"(?<str>(?:#{ESC_SEQ}|[^\\"\n\r])*)"/,
  /'(?<str>(?:#{ESC_SEQ}|[^\\'\n\r])*)'/,
  /#{RAW}"""(?<str>.*?)"""/m,
  /#{RAW}'''(?<str>.*?)'''/m,
  /#{RAW}"(?<str>[^"\n\r]*)"/,
  /#{RAW}'(?<str>[^'\n\r]*)'/,
)

BYTES_REGEX = /[bB]#{STRING_REGEX}/

RESERVED = %W[
as break const continue else
for function if import let
loop package namespace return
var void while
].freeze

IDENTIFIER_REGEX = /[_a-zA-Z][_a-zA-Z0-9]*/

def parse(str)
  tokenize(str)
  do_parse
rescue Racc::ParseError => err
  raise parse_error(err)
end

def parse_error(error)
  parse_error = case error.message
  when /parse error on value "([^"]+)" \(tRESERVED\)/
    Cel::ParseError.new("invalid usage of the reserved word \"#{$1}\"")
  else
    Cel::ParseError.new(error.message)
  end
  parse_error.set_backtrace(error.backtrace)
  parse_error
end

def tokenize(str)
  str.force_encoding(Encoding::BINARY) unless str.valid_encoding?

  scanner = StringScanner.new(str)

  @q = []

  until scanner.eos?
    case
    when scanner.scan(WHITESPACE_REGEX)
      # skip whitespace
    when scanner.scan(COMMENT_REGEX)
      # skip comment lines
    when scanner.scan(NUM_FLOAT_REGEX)
      @q << [:tDOUBLE, Float(scanner.matched)]
    when scanner.scan(NUM_UINT_REGEX)
      @q << [:tUINT, scanner[:hex] ? scanner[:hex].to_i(16) : scanner[:dec].to_i]
    when scanner.scan(NUM_INT_REGEX)
      @q << [:tINT, scanner[:hex] ? scanner[:hex].to_i(16) : scanner[:dec].to_i]
    when scanner.scan(STRING_REGEX)
      @q << [:tSTRING, convert_to_string(scanner[:raw], scanner[:str])]
    when scanner.scan(BYTES_REGEX)
      str = convert_to_string(scanner[:raw], scanner[:str])
      @q << [:tBYTES, convert_to_bytes(str)]
    when scanner.scan(IDENTIFIER_REGEX)
      word = scanner.matched
      if word == "null"
        @q << [:tNULL, nil]
      elsif word == "true"
        @q << [:tBOOL, true]
      elsif word == "false"
        @q << [:tBOOL, false]
      elsif RESERVED.include?(word)
        @q << [:tRESERVED, scanner.matched]
      elsif word == "in"
        @q << [OPERATORS[scanner.matched], scanner.matched]
      else
        @q << [:tIDENTIFIER, scanner.matched]
      end
    when scanner.scan(OPERATORS_RE)
      @q << [OPERATORS[scanner.matched], scanner.matched]
    when scanner.scan(/\A.|\n/o)
      s = scanner.matched
      @q << [s, s]
    else
      raise ParseError, "unexpected value: #{scanner.string}"
    end
  end
  @q << [:tEOF, false]
end

def next_token
  @q.shift
end

CHAR_SEQ_MAP = {
  "\\a" => "\a",
  "\\b" => "\b",
  "\\f" => "\f",
  "\\n" => "\n",
  "\\r" => "\r",
  "\\t" => "\t",
  "\\v" => "\v",
  "\\\"" => "\"",
  "\\'" => "'",
  "\\\\" => "\\",
  "\\?" => "?",
  "\\`" => "`",
}.freeze
ESC_SEQ_REGEX = /#{ESC_SEQ}/
def convert_to_string(raw, str)
  # Raw strings do not interpret escape sequences
  return str if raw

  # Parse and convert all escape sequences
  str.gsub(ESC_SEQ_REGEX) do |match|
    case match[1]
    when "0", "1", "2", "3"
      # Octal sequence - ESC_OCT_SEQ
      match[2..].to_i(8).chr
    when "x", "X"
      # Hex sequence - ESC_BYTE_SEQ
      match[2..].to_i(16).chr
    when "u", "U"
      # Unicode escape sequence - ESC_UNI_SEQ
      [match[2..].to_i(16)].pack('U')
    else
      # Char escape sequence - ESC_CHAR_SEQ
      CHAR_SEQ_MAP.fetch(match)
    end
  end
end

def convert_to_bytes(str)
  str.unpack("C*")
end

---- footer

# if $0 == __FILE__
#   examples = <<EOS
# 123
# 12345
# 1.2
# 1e2
# -1.2e2
# 12u
# 0xa123
# ""
# '""'
# '''x''x'''
# "\""
# "\\"
# r"\\"
# b"abc"
# b"Ã¿"
# b"\303\277"
# "\303\277"
# "\377"
# b"\377"
# "\xFF"
# b"\xFF"

# 1 + 2
# 3 - 2
# " Some String with \"escapes\""
# 'another string'
# a.b.c == 1
# d > 2
# a.b.c * 3 == 1 && d > 2
# a.b.c
# wiri
# // a.driving_license = "CA"
# // 1 = 2
# // 2 = "a"
# // a.b.c > "a"
# EOS
#   puts 'Parsing...'
#   parser = Cel::Parser.new
#   examples.each_line do |line|
#     puts "line: #{line.inspect}"
#     puts parser.parse(line)
#   end
# end

# The grammar of CEL is defined below, using | for alternatives, [] for optional, {} for repeated, and () for grouping.
# Expr           = ConditionalOr ["?" ConditionalOr ":" Expr] ;
# ConditionalOr  = [ConditionalOr "||"] ConditionalAnd ;
# ConditionalAnd = [ConditionalAnd "&&"] Relation ;
# Relation       = [Relation Relop] Addition ;
# Relop          = "<" | "<=" | ">=" | ">" | "==" | "!=" | "in" ;
# Addition       = [Addition ("+" | "-")] Multiplication ;
# Multiplication = [Multiplication ("*" | "/" | "%")] Unary ;
# Unary          = Member
#                | "!" {"!"} Member
#                | "-" {"-"} Member
#                ;
# Member         = Primary
#                | Member "." IDENT ["(" [ExprList] ")"]
#                | Member "[" Expr "]"
#                | Member "{" [FieldInits] "}"
#                ;
# Primary        = ["."] IDENT ["(" [ExprList] ")"]
#                | "(" Expr ")"
#                | "[" [ExprList] "]"
#                | "{" [MapInits] "}"
#                | LITERAL
#                ;
# ExprList       = Expr {"," Expr} ;
# FieldInits     = IDENT ":" Expr {"," IDENT ":" Expr} ;
# MapInits       = Expr ":" Expr {"," Expr ":" Expr} ;

# IDENT          ::= [_a-zA-Z][_a-zA-Z0-9]* - RESERVED
# LITERAL        ::= INT_LIT | UINT_LIT | FLOAT_LIT | STRING_LIT | BYTES_LIT
# | BOOL_LIT | NULL_LIT
# INT_LIT        ::= -? DIGIT+ | -? 0x HEXDIGIT+
# UINT_LIT       ::= INT_LIT [uU]
# FLOAT_LIT      ::= -? DIGIT* . DIGIT+ EXPONENT? | -? DIGIT+ EXPONENT
# DIGIT          ::= [0-9]
# HEXDIGIT       ::= [0-9abcdefABCDEF]
# EXPONENT       ::= [eE] [+-]? DIGIT+
# STRING_LIT     ::= [rR]? ( "    ~( " | NEWLINE )*  "
#         | '    ~( ' | NEWLINE )*  '
#         | """  ~"""*              """
#         | '''  ~'''*              '''
#         )
# BYTES_LIT      ::= [bB] STRING_LIT
# ESCAPE         ::= \ [bfnrt"'\]
# | \ x HEXDIGIT HEXDIGIT
# | \ u HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
# | \ U HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT
# | \ [0-3] [0-7] [0-7]
# NEWLINE        ::= \r\n | \r | \n
# BOOL_LIT       ::= "true" | "false"
# NULL_LIT       ::= "null"
# RESERVED       ::= BOOL_LIT | NULL_LIT | "in"
# | "as" | "break" | "const" | "continue" | "else"
# | "for" | "function" | "if" | "import" | "let"
# | "loop" | "package" | "namespace" | "return"
# | "var" | "void" | "while"
# WHITESPACE     ::= [\t\n\f\r ]+
# COMMENT        ::= '//' ~NEWLINE* NEWLINE
