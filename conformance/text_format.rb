#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.8.1
# from Racc grammar file "text_format.ry".
#

require 'racc/parser.rb'


  require "strscan"

class ProtoTextFormat < Racc::Parser

module_eval(<<'...end text_format.ry/module_eval...', 'text_format.ry', 64)
  COMMENT_REGEX = /#[^\n]*/
  WHITESPACE_REGEX = /[ \n\t\v\f\r]+/

  IDENT_REGEX = /[_a-zA-Z][_a-zA-Z0-9]*/

  HEXDIGIT  = "[0-9a-fA-F]"
  DEC_LIT   = "(?:0|[1-9][0-9]*)"
  EXP       = "(?:[eE][+-]?[0-9]+)"
  FLOAT_LIT = "(?:" + [
    "(?:\\.[0-9]+#{EXP}?)",
    "(?:#{DEC_LIT}\\.[0-9]*#{EXP}?)",
    "(?:#{DEC_LIT}#{EXP})",
  ].join("|") + ")"
  DEC_INT_REGEX = Regexp.new(DEC_LIT)
  OCT_INT_REGEX = /0[0-7]+/
  HEX_INT_REGEX = /0[xX]#{HEXDIGIT}+/
  FLOAT_REGEX   = Regexp.union(/#{FLOAT_LIT}[fF]?/, /#{DEC_LIT}[fF]/)

  BACKSLASH    = "\\\\" # Must be literally two backslashes for proper interpolation
  ESC_CHAR_SEQ = "#{BACKSLASH}[abfnrtv?#{BACKSLASH}'\"]"
  ESC_OCT_SEQ  = "#{BACKSLASH}[0-3][0-7]{2}"
  ESC_HEX_SEQ  = "#{BACKSLASH}x#{HEXDIGIT}{2}"
  ESC_UNI_SEQ  = "#{BACKSLASH}u#{HEXDIGIT}{4}|#{BACKSLASH}U000#{HEXDIGIT}{5}|#{BACKSLASH}U0010#{HEXDIGIT}{4}"
  ESC_SEQ      = "#{ESC_CHAR_SEQ}|#{ESC_HEX_SEQ}|#{ESC_UNI_SEQ}|#{ESC_OCT_SEQ}"
  STRING_REGEX = Regexp.union(
    /'(?<str>(?:#{ESC_SEQ}|[^'\n\\])*)'/,
    /"(?<str>(?:#{ESC_SEQ}|[^"\n\\])*)"/
  )

  def initialize(descriptor)
    @descriptor = descriptor
  end

  def parse(str)
    @root = @message = @descriptor.msgclass.new
    @messages = [@root]
    tokenize(str)
    do_parse
  end

  def tokenize(str)
    @q = []
    scanner = StringScanner.new(str)
    until scanner.eos?
      if scanner.skip(WHITESPACE_REGEX) || scanner.skip(COMMENT_REGEX)
        # Skip
      elsif scanner.scan(FLOAT_REGEX)
        @q << [:FLOAT, scanner.matched]
      elsif scanner.scan(HEX_INT_REGEX) || scanner.scan(OCT_INT_REGEX) || scanner.scan(DEC_INT_REGEX)
        @q << [:INT, scanner.matched]
      elsif scanner.scan(STRING_REGEX)
        @q << [:STRING, scanner[:str]]
      elsif scanner.scan(IDENT_REGEX)
        @q << [:IDENT, scanner.matched]
      elsif scanner.scan(/[-.\/\[\]{}:;,<>]/)
        s = scanner.matched
        @q << [s, s]
      else
        raise "Could not parse: #{scanner.rest[0..50].inspect}"
      end
    end
  end

  def next_token
    @q.shift
  end

  def start_field(field_name)
    # Automatically start new item if current message is repeated
    push_message(@message.new_item) if @message.is_a?(RepeatedMessageField)

    if field_name.is_a?(Array)
      descriptor = Google::Protobuf::DescriptorPool.generated_pool.lookup(field_name.last)
      push_message(descriptor.msgclass.new)
    else
      descriptor = @message.class.descriptor
      field = descriptor.lookup(field_name)
      if field.type == :message
        if field.label == :repeated
          push_message(RepeatedMessageField.new(field.subtype.msgclass))
        else
          push_message(field.subtype.msgclass.new)
        end
      end
    end

    field_name
  end

  def set_scalar_field(field_name, value)
    field = @message.class.descriptor.lookup(field_name)
    if field.type == :bytes
      # By default strings are UTF-8, so we need to tell ruby it has a different
      # encoding before setting, or the protobuf code will try to convert
      field.set(@message, value.force_encoding("ASCII-8BIT"))
    else
      field.set(@message, value)
    end
  end

  def set_message_field(field_name, value)
    # Any object so wrap value
    if field_name.is_a?(Array)
      @message.type_url = field_name.join("/")
      @message.value = value.to_proto
      return
    end

    # Set field
    if @message.is_a?(RepeatedMessageField)
      pop_message # Pop the RepeatedMessageField to get back to the parent message

      field = @message.class.descriptor.lookup(field_name)
      case (field_value = field.get(@message))
      when Google::Protobuf::RepeatedField then field_value.push(value)
      when Google::Protobuf::Map then field_value[value.key] = value.value
      else raise "Unexpected repeated field: #{field_value.inspect}"
      end
    else
      field = @message.class.descriptor.lookup(field_name)
      field.set(@message, value)
    end
  end

  def push_message(message)
    @message = message
    @messages << @message
  end

  def pop_message
    popped = @messages.pop
    @message = @messages.last
    popped
  end

  CHAR_SEQ_MAP = {
    "\\a" => "\a",
    "\\b" => "\b",
    "\\f" => "\f",
    "\\n" => "\n",
    "\\r" => "\r",
    "\\t" => "\t",
    "\\v" => "\v",
    "\\?" => "?",
    "\\\\" => "\\",
    "\\'" => "'",
    "\\\"" => "\"",
  }.freeze
  ESC_SEQ_REGEX = /#{ESC_SEQ}/
  def string_literal(str)
    # Set to binary so we can put invalid characters in from the escapes
    str.force_encoding("ASCII-8BIT")

    # Parse and convert all escape sequences
    str.gsub!(ESC_SEQ_REGEX) do |match|
      case match[1]
      when "0", "1", "2", "3"
        # Octal sequence - ESC_OCT_SEQ
        match[1..].to_i(8).chr
      when "x"
        # Hex sequence - ESC_BYTE_SEQ
        match[2..].to_i(16).chr
      when "u", "U"
        # Unicode escape sequence - ESC_UNI_SEQ
        [match[2..].to_i(16)].pack('U').b
      else
        # Char escape sequence - ESC_CHAR_SEQ
        CHAR_SEQ_MAP.fetch(match)
      end
    end

    # Assume valid UTF-8
    str.force_encoding("UTF-8")
  end

  def float_literal(float_str)
    Float(float_str.sub(/f$/, ""))
  end

  IDENT_LITERALS = {
    "True" => true,
    "true" => true,
    "t" => true,
    "False" => false,
    "false" => false,
    "f" => false,
    "inf" => Float::INFINITY,
    "Infinity" => Float::INFINITY,
    "-inf" => -Float::INFINITY,
    "-Infinity" => -Float::INFINITY,
    "nan" => Float::NAN,
  }.freeze
  def ident_literal(ident)
    if IDENT_LITERALS.key?(ident)
      IDENT_LITERALS[ident]
    else
      # Assume it's an enum, which should be a Ruby symbol
      ident.to_sym
    end
  end

  class RepeatedMessageField
    def initialize(msg_class)
      @msg_class = msg_class
      @values = []
    end

    def new_item
      @msg_class.new
    end

    def <<(message)
      @values << message
    end

    def to_a
      @values
    end
  end
...end text_format.ry/module_eval...
##### State transition tables begin ###

racc_action_table = [
    21,    54,    22,    14,    23,    53,    37,    29,    22,    18,
    23,    34,    35,    36,    38,    37,    25,    46,    51,    26,
    34,    35,    36,    38,    37,    50,    52,    12,    13,    34,
    35,    36,    38,    60,    43,    44,    45,    59,    22,    62,
    23,    45,    12,    13,    16,    17,    12,    13,    12,    13,
    49,    55,    56,    25,    58 ]

racc_action_check = [
     9,    39,    21,     1,    21,    39,    18,    18,     9,     8,
     9,    18,    18,    18,    18,    29,    13,    29,    35,    14,
    29,    29,    29,    29,    60,    35,    35,     0,     0,    60,
    60,    60,    60,    47,    24,    24,    24,    47,    54,    57,
    54,    57,     3,     3,     5,     5,    22,    22,    23,    23,
    30,    41,    42,    44,    45 ]

racc_action_pointer = [
    22,     3,   nil,    37,   nil,    42,   nil,   nil,     5,    -6,
   nil,   nil,   nil,    11,    19,   nil,   nil,   nil,     1,   nil,
   nil,   -12,    41,    43,    27,   nil,   nil,   nil,   nil,    10,
    40,   nil,   nil,   nil,   nil,    13,   nil,   nil,   nil,    -2,
   nil,    36,    35,   nil,    48,    49,   nil,    30,   nil,   nil,
   nil,   nil,   nil,   nil,    24,   nil,   nil,    32,   nil,   nil,
    19,   nil,   nil,   nil ]

racc_action_default = [
    -3,   -45,    -1,    -2,    -5,    -8,    -9,   -10,   -16,   -45,
   -17,   -18,   -19,   -45,   -45,    -4,    -6,    -7,   -15,   -13,
   -14,   -45,    -3,    -3,   -45,   -23,    64,   -11,   -12,   -45,
   -28,   -29,   -30,   -31,   -33,   -45,   -35,   -37,   -39,   -45,
   -42,   -45,   -45,   -20,   -45,   -45,   -24,   -45,   -27,   -32,
   -34,   -36,   -38,   -40,   -45,   -43,   -44,   -45,   -22,   -25,
   -45,   -41,   -21,   -26 ]

racc_goto_table = [
    19,    24,    27,     2,     1,    15,    28,    20,    47,    39,
   nil,   nil,    40,    48,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,    41,    42,   nil,   nil,   nil,
   nil,   nil,    57,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,    63,    61 ]

racc_goto_check = [
    12,    16,     9,     2,     1,     4,    10,    13,    17,    22,
   nil,   nil,    12,     9,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,     2,     2,   nil,   nil,   nil,
   nil,   nil,    16,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,     9,    12 ]

racc_goto_pointer = [
   nil,     4,     3,   nil,     2,   nil,   nil,   nil,   nil,   -16,
   -12,   nil,    -9,    -2,   nil,   nil,   -12,   -21,   nil,   nil,
   nil,   nil,   -12 ]

racc_goto_default = [
   nil,   nil,   nil,     3,     4,     5,     6,     7,     8,   nil,
   nil,     9,   nil,   nil,    10,    11,   nil,   nil,    30,    31,
    32,    33,   nil ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 19, :_reduce_1,
  1, 20, :_reduce_2,
  0, 20, :_reduce_3,
  2, 21, :_reduce_none,
  1, 21, :_reduce_none,
  2, 22, :_reduce_none,
  2, 22, :_reduce_none,
  1, 22, :_reduce_none,
  1, 23, :_reduce_none,
  1, 23, :_reduce_none,
  3, 24, :_reduce_11,
  3, 24, :_reduce_12,
  2, 25, :_reduce_13,
  2, 25, :_reduce_14,
  2, 29, :_reduce_none,
  1, 29, :_reduce_none,
  1, 26, :_reduce_17,
  1, 26, :_reduce_18,
  1, 26, :_reduce_19,
  3, 32, :_reduce_20,
  5, 33, :_reduce_21,
  3, 34, :_reduce_22,
  1, 34, :_reduce_23,
  2, 28, :_reduce_24,
  3, 28, :_reduce_25,
  3, 35, :_reduce_26,
  1, 35, :_reduce_27,
  1, 27, :_reduce_28,
  1, 27, :_reduce_29,
  1, 27, :_reduce_30,
  1, 27, :_reduce_31,
  2, 36, :_reduce_32,
  1, 36, :_reduce_none,
  2, 37, :_reduce_34,
  1, 37, :_reduce_none,
  2, 38, :_reduce_36,
  1, 38, :_reduce_none,
  2, 39, :_reduce_38,
  1, 39, :_reduce_none,
  3, 31, :_reduce_40,
  3, 40, :_reduce_41,
  1, 40, :_reduce_42,
  3, 30, :_reduce_43,
  3, 30, :_reduce_44 ]

racc_reduce_n = 45

racc_shift_n = 64

racc_token_table = {
  false => 0,
  :error => 1,
  ";" => 2,
  "," => 3,
  ":" => 4,
  :IDENT => 5,
  "[" => 6,
  "]" => 7,
  "/" => 8,
  "." => 9,
  :STRING => 10,
  "-" => 11,
  :FLOAT => 12,
  :INT => 13,
  "{" => 14,
  "}" => 15,
  "<" => 16,
  ">" => 17 }

racc_nt_base = 18

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]
Ractor.make_shareable(Racc_arg) if defined?(Ractor)

Racc_token_to_s_table = [
  "$end",
  "error",
  "\";\"",
  "\",\"",
  "\":\"",
  "IDENT",
  "\"[\"",
  "\"]\"",
  "\"/\"",
  "\".\"",
  "STRING",
  "\"-\"",
  "FLOAT",
  "INT",
  "\"{\"",
  "\"}\"",
  "\"<\"",
  "\">\"",
  "$start",
  "target",
  "message",
  "fields",
  "field_with_sep",
  "field",
  "scalar_field",
  "message_field",
  "field_name",
  "scalar_value",
  "scalar_list",
  "message_field_name",
  "message_value",
  "message_list",
  "extension_name",
  "any_name",
  "type_name",
  "scalars",
  "string",
  "float",
  "identifier",
  "int",
  "messages" ]
Ractor.make_shareable(Racc_token_to_s_table) if defined?(Ractor)

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

module_eval(<<'.,.,', 'text_format.ry', 4)
  def _reduce_1(val, _values, result)
     result = @root
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 6)
  def _reduce_2(val, _values, result)
     result = pop_message
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 7)
  def _reduce_3(val, _values, result)
     result = pop_message
    result
  end
.,.,

# reduce 4 omitted

# reduce 5 omitted

# reduce 6 omitted

# reduce 7 omitted

# reduce 8 omitted

# reduce 9 omitted

# reduce 10 omitted

module_eval(<<'.,.,', 'text_format.ry', 17)
  def _reduce_11(val, _values, result)
     set_scalar_field(val[0], val[2])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 18)
  def _reduce_12(val, _values, result)
     @message[val[0]].replace(val[2])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 19)
  def _reduce_13(val, _values, result)
     set_message_field(val[0], val[1])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 20)
  def _reduce_14(val, _values, result)
     @message[val[0]].concat(val[1]); pop_message
    result
  end
.,.,

# reduce 15 omitted

# reduce 16 omitted

module_eval(<<'.,.,', 'text_format.ry', 25)
  def _reduce_17(val, _values, result)
     raise "Extension fields are not supported"
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 26)
  def _reduce_18(val, _values, result)
     result = start_field(val[0])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 27)
  def _reduce_19(val, _values, result)
     result = start_field(val[0])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 28)
  def _reduce_20(val, _values, result)
     result = [val[1]]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 29)
  def _reduce_21(val, _values, result)
     result = [val[1], val[3]]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 30)
  def _reduce_22(val, _values, result)
     result = val.join
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 31)
  def _reduce_23(val, _values, result)
     result = val[0]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 34)
  def _reduce_24(val, _values, result)
     result = []
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 35)
  def _reduce_25(val, _values, result)
     result = val[1]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 36)
  def _reduce_26(val, _values, result)
     result = val[0] << val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 37)
  def _reduce_27(val, _values, result)
     result = [val[0]]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 38)
  def _reduce_28(val, _values, result)
     result = string_literal(val[0])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 39)
  def _reduce_29(val, _values, result)
     result = float_literal(val[0])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 40)
  def _reduce_30(val, _values, result)
     result = ident_literal(val[0])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 41)
  def _reduce_31(val, _values, result)
     result = Integer(val[0])
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 42)
  def _reduce_32(val, _values, result)
     result = val.join
    result
  end
.,.,

# reduce 33 omitted

module_eval(<<'.,.,', 'text_format.ry', 44)
  def _reduce_34(val, _values, result)
     result = val.join
    result
  end
.,.,

# reduce 35 omitted

module_eval(<<'.,.,', 'text_format.ry', 46)
  def _reduce_36(val, _values, result)
     result = val.join
    result
  end
.,.,

# reduce 37 omitted

module_eval(<<'.,.,', 'text_format.ry', 48)
  def _reduce_38(val, _values, result)
     result = val.join
    result
  end
.,.,

# reduce 39 omitted

module_eval(<<'.,.,', 'text_format.ry', 51)
  def _reduce_40(val, _values, result)
     result = val[1]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 52)
  def _reduce_41(val, _values, result)
     result = val[0] << val[2]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 53)
  def _reduce_42(val, _values, result)
     result = [val[0]]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 54)
  def _reduce_43(val, _values, result)
     result = val[1]
    result
  end
.,.,

module_eval(<<'.,.,', 'text_format.ry', 55)
  def _reduce_44(val, _values, result)
     result = val[1]
    result
  end
.,.,

def _reduce_none(val, _values, result)
  val[0]
end

end   # class ProtoTextFormat
